<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Brandon Hewer - MGS 2025 - Refinement types in Haskell</title>
        <link rel="stylesheet" href="./css/compose.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="./">Brandon Hewer</a>
            </div>
            <nav>
                <a href="./">Home</a>
                <a href="./publications.html">Publications</a>
                <a href="./MGS2025.html">MGS 2025</a>
                <a href="./contact.html">Contact</a>
            </nav>
        </header>

        <main role="main">
            <h1>MGS 2025 - Refinement types in Haskell</h1>
            <p>This is the course page for the Midlands Graduate School 2025 (MGS 2025) course on <em>Refinement types in Haskell</em>.</p>
<p>For more information about MGS 2025, see the <a href="https://www.andreipopescu.uk/MGS_Sheffield/MGS2025.html">official website</a>.</p>
<h2 id="course-summary">Course Summary</h2>
<p>Refinement types extend a type system with a notion of decidable subtyping, and support the specification and compile-time verification of a broad range of program properties. Their primary aim is to be a ‘lightweight extension’ of an existing type system, providing a means to reason about program correctness while relying on solvers to automatically verify any proof obligations. Refinement types have been implemented in a variety of languages, including ML (Freeman and Pfenning 1991), Haskell (Vazou et el. 2014), OCaml (Kawaguchi et al.), C (Rondon et al. 2010) and Typescript (Vekris et al. 2016).</p>
<p>This course provides an introduction to refinement types in Liquid Haskell, with a focus on the predicate-based approach. We will examine the application of refinement types to general-purpose functional programming, while introducing key theoretical concepts. The course will also cover some advanced techniques, including termination metrics and higher-order reasoning via abstract refinements. In the final lecture, we will introduce quotient types within the context of a refinement type system.</p>
<p>The course is structured into four lectures:</p>
<ol type="1">
<li>Introduction to refinement types</li>
<li>Refinement logic, datatypes, and subtyping</li>
<li>Measures, termination, and abstract refinements</li>
<li>Quotient types</li>
</ol>
<h2 id="course-resources">Course Resources</h2>
<p>To implement the examples shown on the course, students should install <a href="https://ucsd-progsys.github.io/liquidhaskell/">Liquid Haskell</a>.</p>
<p>Additional course resources will be made available closer to the date.</p>
<h2 id="references">References</h2>
<p>Ming Kawaguchi, Patrick M Rondon, and Ranjit Jhala. 2010. Dsolve: Safety Verification via Liquid Types. In <em>Proceedings of the International Conference on Computer Aided Verification</em>.</p>
<p>Niki Vazou, Eric L Seidel, and Ranjit Jhala, Dimitrios Vytiniotis, and Simon Peyton-Jones. 2014. Refinement Types for Haskell. In <em>Proceedings of the International Conference on Functional Programming</em>.</p>
<p>Panagiotis Vekris, Benjamin Cosman, and Ranjit Jhala. 2016. Refinement types for TypeScript. In <em>Proceedings of the Conference on Programming Language Design and Implementation</em>.</p>
<p>Patrick M Rondon, Ming Kawaguchi, and Ranjit Jhala. 2010. Low-level liquid types. In <em>ACM Sigplan Notices</em>.</p>
<p>Tim Freeman and Frank Pfenning. 1991. Refinement Types for ML. In <em>Proceedings of the Conference on Programming Language Design and Implementation</em>.</p>
        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
